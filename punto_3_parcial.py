# -*- coding: utf-8 -*-
"""punto 3 parcial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kDCs7_U06TvzBbwIVqKovhd6G5pfj4b1
"""

# -------------------------------------------------------
#  APLICACI칍N DE BFS Y DFS EN REDES DE COMUNICACI칍N
# -------------------------------------------------------


import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

# -------------------------------------------------------
#  Construcci칩n del grafo seg칰n la imagen del ejercicio
# -------------------------------------------------------

G = nx.Graph()

# A침adimos las conexiones (aristas no dirigidas)
edges = [
    ("A", "B"),
    ("A", "E"),
    ("B", "D"),
    ("B", "F"),
    ("B", "G"),
    ("E", "F"),
    ("F", "I"),
    ("I", "J"),
    ("J", "G"),
    ("D", "G")
]

G.add_edges_from(edges)

# -------------------------------------------------------
#  ALGORITMO BFS (B칰squeda en Anchura)
# -------------------------------------------------------
def bfs(graph, start):
    visitados = []
    distancia = {nodo: None for nodo in graph.nodes()}
    cola = deque([start])
    distancia[start] = 0

    while cola:
        actual = cola.popleft()
        visitados.append(actual)

        for vecino in graph.neighbors(actual):
            if distancia[vecino] is None:
                distancia[vecino] = distancia[actual] + 1
                cola.append(vecino)

    return visitados, distancia

# Ejecutamos BFS desde A
orden_bfs, distancias_bfs = bfs(G, "A")

print("游댯 ORDEN BFS DESDE A:", orden_bfs)
print("游댯 DISTANCIA M칈NIMA DESDE A:", distancias_bfs)

# -------------------------------------------------------
# ALGORITMO DFS (B칰squeda en Profundidad)
# -------------------------------------------------------
def dfs(graph, start, visitados=None):
    if visitados is None:
        visitados = []
    visitados.append(start)

    for vecino in graph.neighbors(start):
        if vecino not in visitados:
            dfs(graph, vecino, visitados)

    return visitados

# Ejecutamos DFS desde A
orden_dfs = dfs(G, "A")
print("\n游릮 ORDEN DFS DESDE A:", orden_dfs)

# -------------------------------------------------------
#  DETECCI칍N DE SUBREDES DESCONECTADAS
# -------------------------------------------------------
def contar_subredes(graph):
    visitados_global = set()
    componentes = 0

    for nodo in graph.nodes():
        if nodo not in visitados_global:
            componentes += 1
            visitados = dfs(graph, nodo)
            visitados_global.update(visitados)

    return componentes

subredes = contar_subredes(G)
print(f"\n游릭 SUBREDES DESCONECTADAS EN EL GRAFO: {subredes}")

# -------------------------------------------------------
#  VISUALIZACI칍N DEL GRAFO
# -------------------------------------------------------
pos = nx.spring_layout(G)

plt.figure(figsize=(8,6))
nx.draw(
    G, pos, with_labels=True,
    node_size=1200, node_color="skyblue",
    font_size=12, font_weight="bold"
)
plt.title("Red de Servidores (Grafo del Ejercicio)")
plt.show()

"""#Punto B
Justificaci칩n del comportamiento del algoritmo:

DFS (Depth-First Search) siempre intenta avanzar lo m치s profundo posible antes de retroceder.
El recorrido ocurre as칤:

Desde A, el primer vecino es B.

Desde B, el primer vecino no visitado es D.

Desde D, sigue hacia E porque es el siguiente vecino disponible.

Desde E, el 칰nico nodo no visitado es C, as칤 que contin칰a.

Desde C, ya no hay m치s caminos sin visitar, por eso el algoritmo retrocede y termina.

#Punto C
Para identificar cu치ntas subredes hay:

Se elige un nodo y se hace un DFS o BFS.

Todos los nodos alcanzados pertenecen a una misma subred.

Si quedan nodos sin visitar, eso significa que existe otra subred independiente.

Se repite el proceso desde un nodo no visitado.

Cada recorrido nuevo = una subred adicional.

 DFS y BFS permiten detectar autom치ticamente cu치ntos grupos aislados existen en una red, porque ambos recorren completamente todos los nodos accesibles desde un punto inicial.
"""